2/3 truc a voir / faire
split le parsing entre les commandes et les pipes (et les redirections ?)

Refaire le parsing, check caractere par caractere
et si detecte $ lancer fonction qui fait dollar
si detecte quote traitement pareil
si detecte redirection pareil
et on re ecrit qu'une string

Faire une ligne de code a reussir avant la fin de soiree


Si argv[-1] et argv[+1] pas commande, pipe marche pas

PARSING
Check si single et double quote fermer (avec boucle string, et switch)
Change les vars
Separe dans un tableau :
 - Command avec argument
 - pipe "|"
 - redirection < / > / << / >>
Passe toute les redirections du tableau
Les applique
Passe toutes les non redirections
Et check si pipe
Moyen de faire en sorte que ca execute

t < | > e

Ligne qui doivent marcher :
<test rev
<    test    rev
rev <test
rev <test <test2
<test <test2 rev
< test rev | cat -e
< test cat -e | rev

echo " $USER ' '''" '"""' $PAGER   " $PATH " PATCH

echo $ USER == crash PATCH

echo '$USER' $PAGER ee "$USER" == crash   cherche USER" puis crash
Variable trouver : USER"
La variable n'existe pas
munmap_chunk(): invalid pointer
[1]    39607 abort (core dumped)  ./minishell

"echo aaaa" ne doit pas marcher, le parsing annule ca, a voir si d'autre probleme avec le parsing
pres execution qui enleve tout les quotes

gros probleme, le echo "oui        non" ne marchera pas si on envoie pas largument avec les quotes

SOLUTION : moyen d'envoyer plusieurs maillon comme avant
ou
envoyer les quote dans le maillon
